#+startup: beamer

* Workshop introduction
** Workshop introduction
*** Who am I?
**** Composer, programmer, nerd
     - Ph.D., music composition, Duke University (2001).
     - Now: Associate Professor, Xinghai Conservatory, Guangzhou.
     - Subjects: Electronic music production, Film music.
**** Special interests:
     - Danceclub music.
     - Real-time performance with computers.

#+call: makegloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: makegloss

#+name: classgloss
#+call: makegloss(tbl=class,glosstype="class") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: classgloss

#+name: mthgloss
#+call: makegloss(tbl=mth,glosstype="mth") :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: mthgloss

#+call: ugengloss :exports (if hjh-exporting-slides "results" "none") :results value latex
#+results: ugengloss

*** Workshop goals
**** After this workshop, you should understand:
     - How to receive information from external controls;
     - How to apply external data to audio processes;
     - Basics of \egls{granular synthesis}.
     - Basic audio programming concepts, in SuperCollider.
**** At the end, we'll try to perform some music for computer ensemble!

*** Organization of the material
**** Three types of material in this workshop:
     - General :: Useful for all interactive hardware and software. \\
       Your main take-away!
     - OSC/SC :: Specific to Open Sound Control and SuperCollider. \\
       "Implementation details" change with the device and software.
     - Workshop :: The specific way of using OSC and SC for this workshop. \\
       Useful to play with, but don't limit yourself to them.
**** The /general/ principles are the most important to remember.
     You'll see them again and again, in every environment.

*** Overview
**** General outline:
     - Theoretical background.
     - Setup and usage of the SuperCollider environment.
     - Open Sound Control and SuperCollider communication.
     - Granular synthesis fundamentals.
     - Workshop performance interface.
     - Preparing materials for the final performance.

* Interactive audio technology
** Interactive audio technology
*** Interactive audio technology
**** *Interactive audio:* The sound responds in real time.
     Responds to what? Somebody's /action/.
     - People work in the physical world.
     - Computers work with information. \pause
**** The key to interaction:
     #+BEGIN_CENTER
     Physical action $\to$ data (numbers).
     #+END_CENTER

*** Devices for interaction
**** /Action $\to$ data/ requires a control device.
     - *Mouse:* Points at one thing at a time. \pause
     - *Keyboard:* On/off. No smooth changes. \pause
     - *MIDI:* Musically useful. Steers your mind towards "playing an instrument." \pause
     - *Game controllers:* Possible; not often used with computers. \pause
     - *Touchscreens:* Everybody has one! \\
       /Lemur/ is specially designed for electronic arts (but $$$!). \pause
     - *TUIO:* Tangible User Interface Objects (e.g. ReacTable). \pause
     - *Audio/video signals:* Analysis of microphone or webcam input. \pause
     - *Sensors, custom devices:* E.g. Arduino, Leap Motion.

*** This workshop: Touchscreens
**** We'll use phones and tablets in this workshop.
     Mobile control app: *TouchOSC.* \\
     Other apps: 
     - /mrmr/.
     - /Control/ (Charlie Roberts).
     - /OSC Surface/.
     - /QuickOSC/.
     Many more. Search your app store for "OSC."

** About controls
*** Buttons and faders
**** Left							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.65
     :END:
***** Controls divide into two categories:
      - Buttons (按钮) :: Discrete events. \\
        /When/ something should happen.
      - Faders (推子) :: Continuous levels. \\
       	E.g., pitch, volume, pan, speed, etc.
**** Right							      :BMCOL:
     :PROPERTIES:
     :BEAMER_col: 0.3
     :END:
     [[../01/img/touchosc-screen.jpg]]

*** Buttons = triggers
**** Generally, buttons turn things on or off.
     - You need to know /what/ happened, /when/.
     - You don't need a lot of detail.
     - TouchOSC buttons are either 0 or 1.
**** MIDI keyboards.
     - A MIDI keyboard is basically an array of buttons!
     - /Note-on/ and /note-off/.
     - Note number identifies /which/ trigger.
     - Velocity is extra detail, but /doesn't change/ after note-on.

*** Normalized range (IMPORTANT)
**** *Solution:* Normalized vs. actual data /ranges/.
     *Range:* The lowest and highest meaningful numbers for a control.
     - Frequency: 20--20,000 Hz
     - Volume: 0--1 (same as $-\infty$--0 dB).
     - Pan: --1 to 1.
    A \egls{normalized} range is always 0--1.
    - MIDI uses 0--127: $midi \div 127$ is normalized.
**** Physical controls and displays use /normalized/ ranges.
     They don't have to care how the number will be used.

*** Data range mapping
**** To use external information, /map/ it onto a real range.
     Relevant factors:
     - /Size/ of the range: $high - low$.
     - /Offset/: Low boundary's position, relative to 0.
**** $normData \times scale + offset$ is a common pattern.

*** Data range mapping: Panning
**** For example, panning.
     - Real range = --1 to 1.
     - Incoming \gls{normalized} range: 0 to 1.
     - The real range is twice as wide: \\
       Multiply normal range by 2 $\to$ 0 to 2.
     - The real range is shifted lower: \\
       Subtract one: 0 to 2 $\to$ --1 to 1.
#+BEGIN_CENTER
$pan = norm \times 2 - 1$
#+END_CENTER

*** Mapping curves
**** $normData \times scale + offset$ is \egls{linear} mapping.
     - *In:* Straight line 0--1.
     - *Out:* Straight line @@latex:\emph{low}--\emph{high}@@.
     - 0.1 vs. 0.2 feels the same as 0.5 vs. 0.6.
**** This is not right for every case.
     Other mapping styles:
     - \Gls{exponential} :: Useful for frequencies and durations.
     - Curved :: Uses a curve factor to "pull" the straight line toward the left or right.

*** Exponential mapping
**** Frequency is an \egls{exponential} scale.
     - An octave is always $\times 2$.
     - 100 $\to$ 200 goes up an octave.
     - 600 $\to$ 1200 goes up an octave.
     If you use linear mapping for frequency:
     - The low part of the control will produce bigger pitch changes.
     Exponential: Intervals are the same across the entire controller.
**** This also works for rhythm.
     - Short notes take less time---so you need more of them.
**** Demo.

*** Curve mapping
**** Curve: If it doesn't "feel right" to use linear or exponential.
     A \egls{curve factor} bends the line.
     - *Curve = 0:* Straight line.
     - *Curve < 0:* Pulls the line toward the left.
     - *Curve > 0:* Pulls the line toward the right.
     You can "tune" the response how you like.
**** Demo.

*** Physical data range
**** TouchOSC (and SC graphics objects) are /virtual/.
     - They exist in software.
     - Software defines the range.
     - No problem to make it exactly 0--1.
**** The range coming from physical devices may not be 0--1.
     Especially if you're measuring something in the real world.

*** Measurement and calibration
**** /Measure/ and /calibrate/ physical devices.
     *Measurement:*
     - Before doing anything else, look at the raw numbers coming in.
     - How low or high do they tend to go?
     - /Clip/ the range at a reasonable point.
     *Calibration:*
     - Measurements can change based on the environment.
     - You might need to shift the range for performance in different spaces.
**** Demo.

*** External sources: General plan
**** This is a good way to approach new controllers:
     1. /Examine/ the raw data coming in.
	- Print the numbers on screen.
	- Collect them into arrays and make graphs.
	- Look for usable ranges.
     2. /Data repair/. \\
	Only if needed: \Glspl{smoothing filter}, etc.
     3. /Map/ the data onto audio or control inputs.
	- /Normalize/ the raw data if needed.
	- Then convert to the desired range.

* Getting started with SuperCollider
** SC architecture
*** SC is three applications
**** Really? /Three/ applications?
     Yes. They work together:
     - \egls{scide}: SC Integrated Development Environment.
       - Code editor, display, documentation. \pause
     - \egls{sclang}: SC language.
       - IDE sends code to sclang.
       - sclang runs the code, sends printed output back to IDE. \pause
     - \egls{scsynth}: SC synthesis server.
       - sclang sends \gls{OSC} (Open Sound Control) messages to scsynth.
       - scsynth sends audio to the hardware.
       - May also reply to sclang.

*** SC appearance
    Linux, here.
    #+begin_center
    #+attr_latex: :width 1.0\textwidth
    [[../01/img/sc-with-guis.pdf]]
    #+end_center

*** Server/client design
**** *Server/client* design
     :PROPERTIES:
     :BEAMER_act: presentation
     :END:
     - Server does heavier work (e.g., databases).
     - Client makes requests of the server.
**** How does this work for audio?
     - *Brain:* The client (SC language) sends messages to the server.\\
       /Open Sound Control/ (\gls{OSC}) protocol.
       - "Here's a /synthesis definition/."
       - "Use that definition to make noise."
     - *Brawn:* The server calculates the audio and sends to the hardware.

** Using the Integrated Development Environment
*** Usage: IDE
**** The IDE is your main interface.
     IDE elements:
     - *Code panel:* Tabbed view of code documents.
     - *Docklets*
       - /Post window/: Printed results from SC language.
       - /Documents/ panel: List of all open tabs.
       - /Help browser/: Look up just about anything.
     - *Tool panel*: Find/replace, command line, etc.
     - *Status bar*
       - Language and server status.
       - Server control (click on the server status).

*** Asking for help
**** Help system keyboard shortcuts
     - Ctrl-D :: Look up help for the keyword under the cursor.
     - Ctrl-Shift-D :: Pop up a box where you can type the search term.
**** Try it
     - Type \cd{SinOsc} into the code window.
     - Hit \ks{Ctrl-D}.
       - SC reads the help index the first time in the session.
       - It's faster after that.
**** Important help browser features
     - "Search" and "Browse" pages.
     - Table of contents in each help page.

*** Code panel
**** Run code: \ks{Ctrl-Return}
    - Runs a code block, selected code or the current line.
    - /Code block/: \cd{(} at the beginning, \cd{)} at the end.\\
      Convenient to run several lines at once.
#+name: codeblock
#+Caption: A block of code, in parentheses.
#+begin_src {SuperCollider} -i :extract=t
(
(1..10).do { |i|
   i.postln;
};
)
#+End_src
**** Auto-indentation
     The editor will automatically indent the code according to the grouping levels.
     Consistent indentation makes the code easier to read.

*** Code panel: Auto-completion
**** Auto-completion
     The editor can help you type certain names and remember parameter lists.
     1. Type \cd{Sin}. SC knows which /classes/ begin with those letters. Choose \cd{SinOsc}.
     2. Type a dot. SC knows which /messages/ \cd{SinOsc} understands. Choose \cd{ar}.
     3. Type \cd{(}. SC knows the inputs of \cd{SinOsc.ar} and shows them to you.
**** Keystrokes for auto completion:
     - Ctrl-space :: Complete a name.
     - Ctrl-shift-space :: Complete a parameter list inside \cd{()}.

** Error messages
*** TODO Glossary markup for /class/ and /method/		   :noexport:
*** Troubleshooting mistakes
**** You'll make mistakes---maybe a lot, early on.
     SC gives you detailed error text to help you understand what went wrong.
**** Two main categories of errors:
     - Parse errors :: The code doesn't follow SC's rules.\\
       Typo in a \gls{class} name, or another unexpected element.
     - Runtime errors :: The code doesn't do the right thing.\\
       Includes typos in method names.

*** Parse errors
**** Parse errors are usually typos, such as:
     - Misspelled \glspl{class}.
     - Wrong punctuation, e.g. \cd{1. 2.0} instead of \cd{1, 2.0}.
     - Mismatched brackets: \cd{( )}, \cd{[ ]} and @@latex:\cd{\{\}}@@ must be balanced.
**** The error listing shows the problem text and what it expected.
#+BEGIN_EXAMPLE
ERROR: syntax error, unexpected BADTOKEN, expecting ')'
  in file 'selected text'
  line 1 char 13:

  rrand(1, 2.0} 
              ^
#+END_EXAMPLE
**** Often, the real mistake comes before the error is actually detected. :noexport:

*** Runtime errors
**** Most errors occur at runtime.
     That is, the code is syntactically correct, but it does something
     other than what you expected.
**** Most important for now: DoesNotUnderstand error.
     - It means: the \gls{object} "does not understand" what you asked it to do.
     - Most common cause: Misspelled \gls{method} name.
#+BEGIN_EXAMPLE
"abc".find("b");  // OK

"abc".findIt("b");
--> ERROR: Message 'findIt' not understood.
#+END_EXAMPLE

*** SC runtime error output
**** SC dumps a lot of information for runtime errors.
     - The error message.
     - The object(s) involved.
     - A \emph{stack trace}, showing what the interpreter was doing
       when the error happened, and how it got there.
**** For now, just look at the error message.
     As you get more experience, you can look at the stack trace and
     get more information.

** Preparing the environment
   :PROPERTIES:
   :EXPORT_OPTIONS: H:1
   :EXPORT_AUTHOR: H. James Harkins
   :END:
*** Initial installation
**** Before beginning, you should install:
     - SuperCollider 3.7 beta or later.\\
       http://supercollider.github.io/download
     - *Optional:* The /sc3-plugins/ pack (additional synthesis units).
       - Precompiled for OSX and Windows:\\
	 http://sourceforge.net/projects/sc3-plugins/files
       - Linux: Look for packages for your distribution.\\<all>
	 Ubuntu: https://launchpad.net/~supercollider/+archive/ppa.\\
	 Install the /supercollider/ and /supercollider-plugins/ packages.

*** Installing workshop extensions
**** Extensions are for extra features.
     Not part of the base installation.
     - *Note:* This assumes you're starting with no extensions except sc3-plugins.
**** To install:
     1. In SC, run \cd{Platform.userExtensionDir;}.\\
	This tells you where to put the files.
     2. Extract the =extensions.zip= file.
     3. Copy or move the extracted files into the extension directory.

*** For SuperCollider 3.6					   :noexport:
**** Most of you are running SuperCollider 3.6.
     - The workshop depends on some new features.
     - Most of these are included in the extensions.
     - For one, you have to replace a file in the class library.
     - Don't do this if you're using the development version (3.7 alpha)!
**** *SC 3.6:* Copy =ProxyInterfaces.sc.copyToClassLib= into the main class library.
      1. Run this line in SC (except in Windows XP):
	 #+name: ProxyInterfaceCopy
	 #+caption: Run this to find the location of ProxyInterfaces.sc.
	 #+begin_src {SuperCollider}
         AbstractPlayControl.filenameSymbol.asString.dirname.openOS;
	 #+end_src
      2. Copy the file into this location.
      3. Rename it so that its extension is only =sc=.

*** *Yes? No?* Startup file					   :noexport:
**** SC needs to run an extra code file during startup.
     1. In the IDE, /File/ menu $\to$ /Open startup file/.
     2. Copy and paste the line below:
	#+name: startup
	#+caption: Add this line to the startup file.
	#+begin_src {SuperCollider}
	(Platform.userExtensionDir +/+ "psSet-event-type.scd").load;
	#+end_src
     3. Save. Make sure the filename is =startup.scd=.
**** Now, recompile the class library.
     - "Recompiling" resets everything in the language.
     - \ks{Ctrl-Shift-L}

*** Audio setup
**** OSX
     - Can choose the device within SC. See below.
     - Or, choose the device in OSX's audio control panel.
**** Windows
     - You /must/ choose the device within SC.
     - Boot the server, then quit, to get the list of devices.
**** Linux
     - \egls{scsynth} goes through the JACK audio server.
     - All audio configuration, including device, is done in JACK. /qjackctl/ can help.
     - *Start JACK before booting the server!*

*** Setting devices within SC
**** First, get a list of devices.
     - *OSX:* \cd{ServerOptions.devices}
     - *Windows:* Boot the server. Then look for the device list.
**** Set the device in \clss{ServerOptions}.
     - You must quote the device name exactly.
#+begin_src {SuperCollider} -i
s.options.device = "Device Name";
#+end_src
**** Reboot the server.
     - Quit first, if needed.
     - It should use the chosen device now.

*** Windows: ASIO						   :noexport:
**** Strongly recommended to use an ASIO sound driver.
     - The default Microsoft MME driver will work, but its \egls{latency} is very high.
       - Latency: the delay between calculating the audio and hearing it.
       - For live use, 30 ms is too much.
       - MME can go as high as 230 ms!
     - If your soundcard installed an ASIO driver, use it.
     - For the built-in soundcard, use ASIO4ALL.

* Beginning (granular) synthesis
** Audio in SuperCollider: Survival guide
*** Overview of SuperCollider audio
**** Audio synthesis could be a full-year course...
     We will hit the basics:
     - Audio \clsspl{Function}.
       - \eglspl{UGen} (Unit Generators) for audio processing.
       - \eGlspl{control input} to change the synth's behavior.
     - \clss{NodeProxy} and \clss{Ndef}: Easy modification of signals.
**** Focusing on \egls{granular synthesis}.
     Relatively easy to get complex results.

*** A simple synthesizer
**** First, a simple example.
     To show the parts of SC synthesis.
#+name: ndef1
#+caption: A sinewave synthesizer.
#+BEGIN_SRC {SuperCollider} -i :extract=t
s.boot;

Ndef(\sine, { |freq = 440, amp = 0.1|
   (SinOsc.ar(freq) * amp).dup
});

Ndef(\sine).play;
Ndef(\sine).stop;
#+END_SRC

*** Booting the server
**** Audio synthesis happens in the /server/.
     If the server is not running, you get no sound.
**** Ways to boot the server:
     - In code: \cd{s.boot}. \\
       - \ci{s} is usually the /default server/.
       - \mth{boot} is the instruction to that server.
       \cd{object.command} is a normal pattern in SC.
     - In the IDE:
       - /Language/ menu $\to$ /Boot Server/.
       - Click on server status bar $\to$ /Boot Server/.

*** Functions
**** \Glspl{Function} appear in curly braces.
     @@latex:\cd{\{ \ldots{} \}}@@. \\
     Parts of a function:
     1. \eGlspl{argument}: Data coming in from outside. (Optional.)
     2. \eGlspl{variable}: Places to remember information locally. (Optional.)
     3. /Expressions/: Do the work.
     The last expression is the function's /return value/.

*** Audio functions
**** Audio functions are different only in what they do.
     - Functions, in general, can do anything.
     - Audio functions /build networks of \glspl{UGen}/.
**** Parts of an audio function:
     1. \eGlspl{argument} become \eglspl{control input}. \\
	External controls feed into control inputs.
     2. \eGlspl{variable} are assigned \glspl{UGen}.
     3. The return value is the final signal.

*** Unit generators
**** \glspl{UGen} represent signal processing operations.
     - E.g., \ugen{SinOsc} to produce a sinewave.
     - Many types of UGens: Oscillators, filters, envelopes, etc.
**** UGens are written like this:
#+BEGIN_CENTER
\cd{UGen.rate(inputs)}
#+END_CENTER
     - UGen :: Its name, starting with a Capital.
     - rate :: \ci{ar} = audio \gls{rate}, \ci{kr} = control rate.
     - inputs :: A list, separated by commas.

*** UGen rates
**** Signals calculate /n/ numbers per second.
     The \egls{rate} controls how many.
     - \mth{ar} :: Audio rate: A separate calculation for every audio output sample.
     - \mth{kr} :: Control rate: Fewer calculations (saves CPU for slower-moving signals, e.g. LFOs).
     - \mth{ir} :: Initial rate: Calculates once, and holds forever.

*** Control inputs
**** Two forms for \glspl{control input}:
     - \cd{\textbar name = default, name = default\textbar}
     - \cd{arg name = default, name = default;}
     Both behave the same.
**** What's a \egls{default}?
     - The input has to start with some number.
     - If you leave out the default, it will assume 0.
     - 0 is meaningless for some parameters: \\
       Frequency = 0 is silent.
     *Get in the habit of writing defaults.*

*** Control inputs are UGens
**** Important rule in SC audio processing:
     *If it changes, it must be a \gls{UGen}*.
**** \Glspl{control input}' values change from outside.
     So, they must be UGens!
     - SC scans the argument list and builds \ci{Control} units automatically.
     - Passing controls into other UGens is the same as passing UGens into other UGens.

*** Connections: UGen $\to$ input
**** {1.0\textwidth}{2.5in}				      :B_overlayarea:
     :PROPERTIES:
     :BEAMER_env: overlayarea
     :END:
#+BEGIN_SRC {SuperCollider} -i
Ndef(\sine, { |freq = 440, amp = 0.1|
   (SinOsc.ar(freq) * amp).dup
});
#+END_SRC
***** O1							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 1
      :END:
****** \ci{freq} and \ci{amp} are control inputs.
       - \ci{freq} appears in parentheses for \ugen{SinOsc}.
       - This creates a connection:
#+BEGIN_CENTER
\ci{freq} $\to$ frequency of \ugen{SinOsc}
#+END_CENTER
***** O2							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 2
      :END:
****** \cd{* amp}... that looks like math.
       Math on \glspl{UGen} produces a /math UGen/!
       - Operator: Multiplication (*).
       - Left side: \ci{SinOsc} (audio rate UGen).
       - Right side: \ci{amp} (control rate UGen).
       Signal = Multiplication result (audio rate). \\
       In audio, multiplication is an amplifier.
***** O3							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 3
      :END:
****** \mth{dup} is not a UGen.
       - The \ugen{SinOsc} is mono (one channel).
       - Multiplying it by the amplifier is also mono.
       - For stereo, we need two copies: @@latex:\emph{dup}licate@@. \\
	 See also panning UGens: \ugen{Pan2}, \ugen{Balance2}.
       Duplication just sends one result to two places. It doesn't calculate anything new.
***** O4							  :B_onlyenv:
      :PROPERTIES:
      :BEAMER_env: onlyenv
      :BEAMER_act: 4
      :END:
****** Left							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.6
       :END:
******* The code produces a signal chain like this.
	- We don't know the actual numbers yet.
	- But we can see /how/ they will calculate.
	(\ugen{Out} is implied with \clss{Ndef}.)
****** Right							      :BMCOL:
       :PROPERTIES:
       :BEAMER_col: 0.25
       :END:
       [[../01/img/synth-graph.pdf]]

*** Synthesis functions: Summary
**** In a synthesis function:
     1. Declare your \eglspl{control input} and \eglspl{default}.
     2. Create signal processing \eglspl{UGen}. \\
	Connect them by supplying other UGens as inputs.
     3. The last expression is the result signal.

*** Using control inputs
**** To change control inputs from outside, \mth{set} them.
     \cd{theSynth.set(\textbackslash name, value, \textbackslash name, value...)}.
     - External control: Controller $\to$ range mapping $\to$ \mth{set} statement.
#+name: ndset1
#+caption: Setting control inputs to new values.
#+BEGIN_SRC {SuperCollider} -i
Ndef(\sine).set(\freq, 220);
Ndef(\sine).set(\freq, 9000);
Ndef(\sine).set(\freq, 300);

Ndef(\sine).set(\amp, 0.5);
Ndef(\sine).set(\amp, 0);
Ndef(\sine).set(\amp, 0.1);
#+END_SRC

*** What is Ndef?
**** \clss{Ndef} represents a signal on the server.
     - Refer to the signal by name, in lots of contexts.
     - You can /change/ the signal's source at any time.
**** Part of the /Just-In-Time' Library/ (\gls{JITLib}).
     Basic idea: Relationships are independent of content.
     - Signals are \eglspl{proxy}: Placeholders for something else.
     - Put any signal into any placeholder, at any time.
     - Set up relationships between proxies, at any time.
     Great for experimenting!

*** Proxies and "set"
**** What if you want a signal to control frequency?
     1. Make another \clss{Ndef}.
	- Output should be in the frequency range.
	- /Control rate/, matching the control input's rate.
     2. Set the control input to the \clss{Ndef}.
#+name: ndset2
#+caption: Set the control input to another proxy: Modulation.
#+BEGIN_SRC {SuperCollider} -i
Ndef(\randF, {
   LFDNoise1.kr(10).exprange(200, 800)
});

Ndef(\sine).set(\freq, Ndef(\randF));
#+END_SRC

** Granular synthesis

* Footnotes

[fn:ecfb5ae3] Heard in a lecture by Jeffrey Stolet (U of Oregon).

